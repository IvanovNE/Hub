# Паттерн проектирования Multiton (Пул одиночек / Registry of singletons) и пример его реализации на языке программирования C# (на платформе .NET4).

## 1. Описание

### Паттерн Multiton интересен тем, что по сути представляет собой частичную совокупность двух паттернов проектирования: Singletone (Одиночка) и Object pool (Пул обьектов).
#### Multitone позволяет создать определенное число своих экземпляров и предоставляет точку доступа для работы с ними. При этом каждый экземпляр связан с уникальным идентификатором.
#### Пул одиночек может использоваться в случае, когда необходимо предоставить доступ к определенным данным из различных блоков приложения. Другой случай – взаимодействие с аппаратным обеспечением через экземпляры одного и того же класса. Например, обмен данными с сетью контроллеров, опрос группы серверов или рабочих станций в сети. Все эти примеры объединяет одно: число экземпляров класса может (и даже должно) быть ограничено и они глобальные для всего приложения.
#### Если рассматривать данный паттерн как объединение идей Одиночки и Пула объектов, можно определить его свойства:
  #####   1) Multitone может использоваться как с жестко заданным списком экземпляров, так и с созданием по требованию.
  #####   2) Если список фиксированный, то возможно создание всех экземпляров при старте программы или обращению к любому из них.
  #####   3) Возможны два варианта реакции на запрос экземпляра с неизвестным идентификатором: отказ или создание нового.
  #####   4) Минусом шаблона является возможность появления большого числа зависимых от него частей приложения. Однако, как и в случае с        Одиночкой, это можно смягчить используя Внедрение зависимостей (Dependency injection).

| Singletone | Object pool | Multitone |
| :------: | :------: | :------: |
| Создает единственный экземпляр своего класса и обеспечивает доступ к нему. | Создаёт и содержит определенное число экземпляров заданного класса, не зная ничего о их сути. | Создает и содержит заданное число экземпляров своего класса. Обеспечивает их идентификацию и точку доступа к ним. |
| Гарантирует существование единственного экземпляра. | Не ограничивает создание других экземпляров заданного класса вне шаблона и ничего не знает о них. | Контролирует количество экземпляров. |

## 2. Реализация в общем виде

![.](https://github.com/Nikita-Ivanov347/Hub/blob/master/Multitone.png)

### Определяем параметры использования шаблона:
  #####  - условие, ограничивающее общее число экземпляров;
  #####  - реакцию на запрос с неизвестным идентификатором;
  #####  - создаются ли экземпляры сразу или только по запросу;
  #####  - объявляем только закрытый конструктор, чтобы запретить создание экземпляров извне;
  #####  - создаем закрытый контейнер для размещения экземпляров;
  #####  - предоставляем доступ к нему через метод;
  #####  - клиентский код использует этот метод для получения нужного экземпляра класса.

## 3. Реализация на .NET4

### Идентификаторами будут выступать значения типа string. Ограничений по списку экземпляров не будет. Это значит, что на любой запрос будет возвращен существующий объект или создан новый. В качестве контейнера объектов возьмем ConcurrentDictionary, входящий в .NET 4. От обычного Dictionary этот вариант отличается потокобезопасностью.

    public sealed class Multiton {
   
     private static readonly ConcurrentDictionary<string, Multiton> _instances 
          = new ConcurrentDictionary<string, Multiton>();

      private Multiton(string key) { /* SKIPPED */ }

      public static Multiton GetInstance(string key)
      {
          return Multiton._instances.GetOrAdd(key, (x) => new Multiton(x));
      }
    } 
    
#####  - экземпляры класса хранятся в контейнере _instances;
#####  - создать самостоятельно экземпляр не возможно, т.к. конструктор закрыт;
#####  - на конструктор возложена обязанность создавать экземпляры в зависимости от указанного идентификатора;
#####  - метод GetInstance() возвращает экземпляр по указанному ключу. При этом вызываемый им метод GetOrAdd() проверяет есть ли готовый объект в контейнере и, если такой не найден, создает новый.

## 4. Улучшенная реализация

  ####   Сделаем так, чтобы реализация не завесила от типа идентификаторов экземпляра. Оставим этот выбор программисту, который будет с ней работать. Для этого используем generic-тип (TKey).
  ####   Добавим контроль над созданием экземпляров. Такая возможность хоть и была в прошлом варианте, но исключения при создании экземпляра это не всегда удобно и даже не всегда необходимо. Разрешим вызывающему коду самому определять дальнейшие действия при невозможности выдать ему объект. Для этого потребуется аналог метода GetOrAdd(), но с учетом возможности отказа в порождении. Поэтому для контейнера теперь используем класс Dictionary.
  ####   Кроме того, добавим параметризованный фабричный метод FactoryMethod(). Теперь он будет отвечать за создание экземпляра класса. Если для указанного идентификатора его создать нельзя, то будет возвращено значение по умолчанию (null).
  ####   Разрешим пользователю удалять единичные экземпляры (метод Remove()) или выполнить полную очистку (метод Clear()).
  ####   Добавим метод GetExistingInstance(), который возвращает только существующие экземпляры.
  
    public sealed class Multiton<TKey>
    {
       private static readonly Dictionary<TKey, Multiton<TKey>> _instances
          = new Dictionary<TKey, Multiton<TKey>>();

      private Multiton(TKey key) { /* SKIPPED */ }

      public static Multiton<TKey> GetInstance(TKey key)
      {
          Multiton<TKey> instance = null;
          if (Multiton<TKey>._instances.TryGetValue(key, out instance)) {
              return instance;
          }

          lock (Multiton<TKey>._instances) {
              if (Multiton<TKey>._instances.TryGetValue(key, out instance)) {
                  return instance;
              }

              instance = Multiton<TKey>.FactoryMethod(key);
              if (instance != null) {
                  Multiton<TKey>._instances.Add(key, instance);
              }
          }

          return instance;
      }

      public static bool GetExistingInstance(TKey key, out Multiton<TKey> instance)
      {
          return Multiton<TKey>._instances.TryGetValue(key, out instance);
      }

      public static void Clear()
      {
          Multiton<TKey>._instances.Clear();
      }

      public static void Remove(TKey key)
      {
          Multiton<TKey>._instances.Remove(key);
      }

      private static Multiton<TKey> FactoryMethod(TKey key)
      {
          return new Multiton<TKey>(key);
      }
    }
    
   #### Полученный класс можно использовать как основу при разработке собственной реализации. Нужно изменить код конструктора и фабричного метода, а так же добавить необходимые свойства и методы. Его использование может выглядеть так:
    
    var obj1 = Multiton<int>.GetInstance(1);
    var obj2 = Multiton<int>.GetInstance(1);
    obj2.DoSomething();
 
    Multiton<int> obj3;
    Multiton<int>.GetExistingInstance(2, out obj3);
    
#### В данном примере obj1 и obj2 будут содержать ссылку на один и тот же объект. Переменная obj3 будет равна null, т.к. экземпляр с идентификатором 2 еще не создан.
